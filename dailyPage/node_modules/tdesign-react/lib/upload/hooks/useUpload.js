/**
 * tdesign v0.42.2
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../../_chunks/dep-ebef14de.js';
import { _ as _toConsumableArray } from '../../_chunks/dep-88be14a4.js';
import { _ as _slicedToArray } from '../../_chunks/dep-2baf8638.js';
import { useRef, useState, useMemo, useEffect } from 'react';
import { m as merge_1 } from '../../_chunks/dep-98b209dd.js';
import { getTriggerTextField, getDisplayFiles, validateFile, getFilesAndErrors, upload } from '../../_common/js/upload/main.js';
import { getFileUrlByFileRaw } from '../../_common/js/upload/utils.js';
import useControlled from '../../hooks/useControlled.js';
import useConfig from '../../hooks/useConfig.js';
import { useLocaleReceiver } from '../../locale/LocalReceiver.js';
import '../../_chunks/dep-24599104.js';
import '../../_chunks/dep-1304d812.js';
import '../../_chunks/dep-339b0951.js';
import '../../_chunks/dep-ba4fa05d.js';
import '../../_chunks/dep-00ad7a91.js';
import '../../_chunks/dep-cf61d761.js';
import '../../_chunks/dep-3627969a.js';
import '../../_chunks/dep-056b9d81.js';
import '../../_chunks/dep-86599c44.js';
import '../../_chunks/dep-de91e914.js';
import '../../_chunks/dep-f60756e1.js';
import '../../_chunks/dep-090fa3b2.js';
import '../../_chunks/dep-a98a054e.js';
import '../../_chunks/dep-7a725039.js';
import '../../_chunks/dep-e48ce47b.js';
import '../../_chunks/dep-d9495851.js';
import '../../_chunks/dep-c393cab2.js';
import '../../_chunks/dep-75ee7646.js';
import '../../_chunks/dep-68ef3987.js';
import '../../_chunks/dep-7237da98.js';
import '../../_chunks/dep-d905b9e9.js';
import '../../_chunks/dep-87e9108c.js';
import '../../_chunks/dep-873eecd0.js';
import '../../_common/js/upload/xhr.js';
import '../../_common/js/log/log.js';
import '../../_chunks/dep-8f4dca99.js';
import '../../_chunks/dep-65354ae3.js';
import '../../_chunks/dep-4192679d.js';
import '../../_chunks/dep-2998e451.js';
import '../../_chunks/dep-893e0247.js';
import '../../_util/noop.js';
import '../../config-provider/ConfigContext.js';
import '../../_common/js/global-config/locale/zh_CN.js';
import '../../_common/js/global-config/default-config.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function useUpload(props) {
  var inputRef = useRef();
  var disabled = props.disabled,
      autoUpload = props.autoUpload,
      isBatchUpload = props.isBatchUpload;

  var _useConfig = useConfig(),
      classPrefix = _useConfig.classPrefix;

  var _useLocaleReceiver = useLocaleReceiver("upload"),
      _useLocaleReceiver2 = _slicedToArray(_useLocaleReceiver, 2),
      globalLocale = _useLocaleReceiver2[0],
      t = _useLocaleReceiver2[1];

  var _useControlled = useControlled(props, "files", props.onChange),
      _useControlled2 = _slicedToArray(_useControlled, 2),
      uploadValue = _useControlled2[0],
      setUploadValue = _useControlled2[1];

  var xhrReq = useRef([]);

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      toUploadFiles = _useState2[0],
      setToUploadFiles = _useState2[1];

  var _useState3 = useState(""),
      _useState4 = _slicedToArray(_useState3, 2),
      sizeOverLimitMessage = _useState4[0],
      setSizeOverLimitMessage = _useState4[1];

  var locale = useMemo(function () {
    return merge_1({}, globalLocale, props.locale);
  }, [globalLocale, props.locale]);
  var tipsClasses = "".concat(classPrefix, "-upload__tips ").concat(classPrefix, "-size-s");
  var errorClasses = [tipsClasses].concat("".concat(classPrefix, "-upload__tips-error"));
  var triggerUploadText = useMemo(function () {
    var _uploadValue$;

    var field = getTriggerTextField({
      isBatchUpload: isBatchUpload,
      multiple: props.multiple,
      status: uploadValue === null || uploadValue === void 0 ? void 0 : (_uploadValue$ = uploadValue[0]) === null || _uploadValue$ === void 0 ? void 0 : _uploadValue$.status,
      autoUpload: autoUpload
    });
    return locale.triggerUploadText[field];
  }, [locale.triggerUploadText, uploadValue, props.multiple, isBatchUpload, autoUpload]);

  var _useState5 = useState(false),
      _useState6 = _slicedToArray(_useState5, 2),
      uploading = _useState6[0],
      setUploading = _useState6[1];

  var _useState7 = useState(uploadValue),
      _useState8 = _slicedToArray(_useState7, 2),
      displayFiles = _useState8[0],
      setDisplayFiles = _useState8[1];

  useEffect(function () {
    var files = getDisplayFiles({
      multiple: props.multiple,
      toUploadFiles: toUploadFiles,
      uploadValue: _toConsumableArray(uploadValue),
      autoUpload: autoUpload,
      isBatchUpload: isBatchUpload
    });
    setDisplayFiles(files);
  }, [props.multiple, toUploadFiles, uploadValue, autoUpload, isBatchUpload]);

  var updateProgress = function updateProgress(p, toFiles, trigger) {
    if (props.autoUpload) {
      setToUploadFiles(_toConsumableArray(toFiles));
    } else {
      setUploadValue(_toConsumableArray(uploadValue), {
        e: p.event,
        trigger: trigger,
        index: uploadValue.length,
        file: p.files[0]
      });
    }
  };

  var _onResponseError = function onResponseError(p, toFiles) {
    var _props$onOneFileFail;

    if (!p || !p.files || !p.files[0]) return;

    if (toFiles) {
      updateProgress(p, toFiles, "progress-fail");
    }

    var response = p.response,
        event = p.event,
        files = p.files;
    (_props$onOneFileFail = props.onOneFileFail) === null || _props$onOneFileFail === void 0 ? void 0 : _props$onOneFileFail.call(props, {
      e: event,
      file: files === null || files === void 0 ? void 0 : files[0],
      currentFiles: files,
      failedFiles: files,
      response: response
    });
  };

  var _onResponseProgress = function onResponseProgress(p, toFiles) {
    var _props$onProgress;

    updateProgress(p, toFiles, "progress");
    (_props$onProgress = props.onProgress) === null || _props$onProgress === void 0 ? void 0 : _props$onProgress.call(props, {
      e: p.event,
      file: p.file,
      currentFiles: p.files,
      percent: p.percent,
      type: p.type
    });
  };

  var _onResponseSuccess = function onResponseSuccess(p, toFiles) {
    if (props.multiple && !props.uploadAllFilesInOneRequest) {
      var _props$onOneFileSucce;

      updateProgress(p, toFiles, "progress-success");
      (_props$onOneFileSucce = props.onOneFileSuccess) === null || _props$onOneFileSucce === void 0 ? void 0 : _props$onOneFileSucce.call(props, {
        e: p.event,
        file: p.files[0],
        response: p.response
      });
    }
  };

  function getSizeLimitError(sizeLimitObj) {
    var limit = sizeLimitObj;
    return limit.message ? t(limit.message, {
      sizeLimit: limit.size
    }) : "".concat(t(locale.sizeLimitMessage, {
      sizeLimit: limit.size
    }), " ").concat(limit.unit);
  }

  var handleNonAutoUpload = function handleNonAutoUpload(toFiles) {
    var tmpFiles = props.multiple && !isBatchUpload ? uploadValue.concat(toFiles) : toFiles;

    if (["image", "image-flow"].includes(props.theme)) {
      var list = tmpFiles.map(function (file) {
        return new Promise(function (resolve) {
          getFileUrlByFileRaw(file.raw).then(function (url) {
            resolve(_objectSpread(_objectSpread({}, file), {}, {
              url: url
            }));
          });
        });
      });
      Promise.all(list).then(function (files) {
        setUploadValue(files, {
          trigger: "add",
          index: uploadValue.length,
          file: files[0]
        });
      });
    } else {
      setUploadValue(tmpFiles, {
        trigger: "add",
        index: uploadValue.length,
        file: tmpFiles[0]
      });
    }

    setToUploadFiles([]);
  };

  var onFileChange = function onFileChange(files) {
    var _props$onSelectChange;

    if (disabled) return;
    (_props$onSelectChange = props.onSelectChange) === null || _props$onSelectChange === void 0 ? void 0 : _props$onSelectChange.call(props, _toConsumableArray(files), {
      currentSelectedFiles: toUploadFiles
    });
    validateFile({
      uploadValue: uploadValue,
      files: _toConsumableArray(files),
      allowUploadDuplicateFile: props.allowUploadDuplicateFile,
      max: props.max,
      sizeLimit: props.sizeLimit,
      isBatchUpload: isBatchUpload,
      autoUpload: autoUpload,
      format: props.format,
      beforeUpload: props.beforeUpload,
      beforeAllFilesUpload: props.beforeAllFilesUpload
    }).then(function (args) {
      var _args$validateResult;

      if (((_args$validateResult = args.validateResult) === null || _args$validateResult === void 0 ? void 0 : _args$validateResult.type) === "BEFORE_ALL_FILES_UPLOAD") return;

      if (args.lengthOverLimit) {
        var _props$onValidate;

        (_props$onValidate = props.onValidate) === null || _props$onValidate === void 0 ? void 0 : _props$onValidate.call(props, {
          type: "FILES_OVER_LENGTH_LIMIT",
          files: args.files
        });
      }

      if (args.hasSameNameFile) {
        var _props$onValidate2;

        (_props$onValidate2 = props.onValidate) === null || _props$onValidate2 === void 0 ? void 0 : _props$onValidate2.call(props, {
          type: "FILTER_FILE_SAME_NAME",
          files: args.files
        });
      }

      if (args.fileValidateList instanceof Array) {
        var _props$onWaitingUploa;

        var _getFilesAndErrors = getFilesAndErrors(args.fileValidateList, getSizeLimitError),
            sizeLimitErrors = _getFilesAndErrors.sizeLimitErrors,
            toFiles = _getFilesAndErrors.toFiles;

        var tmpWaitingFiles = autoUpload ? toFiles : toUploadFiles.concat(toFiles);
        (_props$onWaitingUploa = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa === void 0 ? void 0 : _props$onWaitingUploa.call(props, {
          files: tmpWaitingFiles,
          trigger: "validate"
        });

        if (sizeLimitErrors[0]) {
          var _props$onValidate3;

          setSizeOverLimitMessage(sizeLimitErrors[0].file.response.error);
          (_props$onValidate3 = props.onValidate) === null || _props$onValidate3 === void 0 ? void 0 : _props$onValidate3.call(props, {
            type: "FILE_OVER_SIZE_LIMIT",
            files: sizeLimitErrors.map(function (t2) {
              return t2.file;
            })
          });
        } else {
          setSizeOverLimitMessage("");
        }

        if (autoUpload) {
          setToUploadFiles(tmpWaitingFiles);
          uploadFiles(tmpWaitingFiles);
        } else {
          handleNonAutoUpload(tmpWaitingFiles);
        }
      }
    });
    inputRef.current.value = null;
  };

  var onNormalFileChange = function onNormalFileChange(e) {
    onFileChange === null || onFileChange === void 0 ? void 0 : onFileChange(e.target.files);
  };

  function onDragFileChange(e) {
    onFileChange === null || onFileChange === void 0 ? void 0 : onFileChange(e.dataTransfer.files);
  }

  function uploadFiles(toFiles) {
    var notUploadedFiles = uploadValue.filter(function (t2) {
      return t2.status !== "success";
    });
    var files = autoUpload ? toFiles : notUploadedFiles;
    if (!files || !files.length) return;
    xhrReq.current = [];
    setUploading(true);
    upload({
      action: props.action,
      headers: props.headers,
      withCredentials: props.withCredentials,
      uploadedFiles: uploadValue,
      toUploadFiles: files,
      multiple: props.multiple,
      isBatchUpload: isBatchUpload,
      autoUpload: autoUpload,
      uploadAllFilesInOneRequest: props.uploadAllFilesInOneRequest,
      useMockProgress: props.useMockProgress,
      data: props.data,
      requestMethod: props.requestMethod,
      formatRequest: props.formatRequest,
      formatResponse: props.formatResponse,
      onResponseProgress: function onResponseProgress(p) {
        return _onResponseProgress(p, toFiles);
      },
      onResponseSuccess: function onResponseSuccess(p) {
        return _onResponseSuccess(p, toFiles);
      },
      onResponseError: function onResponseError(p) {
        return _onResponseError(p, toFiles);
      },
      setXhrObject: function setXhrObject(xhr) {
        var _xhr$files$;

        if ((_xhr$files$ = xhr.files[0]) !== null && _xhr$files$ !== void 0 && _xhr$files$.raw && xhrReq.current.find(function (item) {
          return item.files[0].raw === xhr.files[0].raw;
        })) return;
        xhrReq.current = xhrReq.current.concat(xhr);
      }
    }).then(function (_ref) {
      var status = _ref.status,
          data = _ref.data,
          list = _ref.list,
          failedFiles = _ref.failedFiles;
      setUploading(false);

      if (status === "success") {
        var _props$onSuccess;

        if (props.autoUpload) {
          setUploadValue(_toConsumableArray(data.files), {
            trigger: "add",
            file: data.files[0]
          });
        }

        (_props$onSuccess = props.onSuccess) === null || _props$onSuccess === void 0 ? void 0 : _props$onSuccess.call(props, {
          fileList: data.files,
          currentFiles: files,
          file: files[0],
          results: list === null || list === void 0 ? void 0 : list.map(function (t2) {
            return t2.data;
          }),
          response: data.response || list.map(function (t2) {
            return t2.data.response;
          })
        });
        xhrReq.current = [];
      } else if (failedFiles !== null && failedFiles !== void 0 && failedFiles[0]) {
        var _props$onFail;

        (_props$onFail = props.onFail) === null || _props$onFail === void 0 ? void 0 : _props$onFail.call(props, {
          e: data.event,
          file: failedFiles[0],
          failedFiles: failedFiles,
          currentFiles: files,
          response: data.response
        });
      }

      if (autoUpload) {
        var _props$onWaitingUploa2;

        setToUploadFiles(failedFiles);
        (_props$onWaitingUploa2 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa2 === void 0 ? void 0 : _props$onWaitingUploa2.call(props, {
          files: failedFiles,
          trigger: "uploaded"
        });
      }
    }, function (p) {
      _onResponseError(p);

      setUploading(false);
    });
  }

  function onRemove(p) {
    var _props$onRemove;

    setSizeOverLimitMessage("");
    var changePrams = {
      e: p.e,
      trigger: "remove",
      index: p.index,
      file: p.file
    };

    if (isBatchUpload || !props.multiple) {
      var _props$onWaitingUploa3;

      (_props$onWaitingUploa3 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa3 === void 0 ? void 0 : _props$onWaitingUploa3.call(props, {
        files: [],
        trigger: "remove"
      });
      setUploadValue([], changePrams);
      setToUploadFiles([]);
      xhrReq.current = [];
    } else if (!props.autoUpload) {
      uploadValue.splice(p.index, 1);
      setUploadValue(_toConsumableArray(uploadValue), changePrams);
    } else if (p.index < uploadValue.length) {
      uploadValue.splice(p.index, 1);
      setUploadValue(_toConsumableArray(uploadValue), changePrams);
    } else {
      var _props$onWaitingUploa4;

      var tmpFiles = _toConsumableArray(toUploadFiles);

      tmpFiles.splice(p.index - uploadValue.length, 1);
      setToUploadFiles(_toConsumableArray(tmpFiles));
      (_props$onWaitingUploa4 = props.onWaitingUploadFilesChange) === null || _props$onWaitingUploa4 === void 0 ? void 0 : _props$onWaitingUploa4.call(props, {
        files: _toConsumableArray(tmpFiles),
        trigger: "remove"
      });
    }

    (_props$onRemove = props.onRemove) === null || _props$onRemove === void 0 ? void 0 : _props$onRemove.call(props, p);
  }

  var triggerUpload = function triggerUpload() {
    if (disabled) return;
    inputRef.current.click();
  };

  var cancelUpload = function cancelUpload(context) {
    var _xhrReq$current;

    (_xhrReq$current = xhrReq.current) === null || _xhrReq$current === void 0 ? void 0 : _xhrReq$current.forEach(function (item) {
      var _item$xhrReq;

      (_item$xhrReq = item.xhrReq) === null || _item$xhrReq === void 0 ? void 0 : _item$xhrReq.abort();
    });
    setUploading(false);

    if (autoUpload) {
      setToUploadFiles(toUploadFiles.map(function (item) {
        return _objectSpread(_objectSpread({}, item), {}, {
          status: "waiting"
        });
      }));
    } else {
      setUploadValue(uploadValue.map(function (item) {
        if (item.status !== "success") {
          return _objectSpread(_objectSpread({}, item), {}, {
            status: "waiting"
          });
        }

        return item;
      }), {
        trigger: "abort"
      });
    }

    if (context !== null && context !== void 0 && context.file) {
      onRemove === null || onRemove === void 0 ? void 0 : onRemove({
        file: context.file,
        e: context.e,
        index: 0
      });
    }
  };

  return {
    t: t,
    locale: locale,
    classPrefix: classPrefix,
    triggerUploadText: triggerUploadText,
    toUploadFiles: toUploadFiles,
    uploadValue: uploadValue,
    displayFiles: displayFiles,
    sizeOverLimitMessage: sizeOverLimitMessage,
    uploading: uploading,
    tipsClasses: tipsClasses,
    errorClasses: errorClasses,
    inputRef: inputRef,
    disabled: disabled,
    xhrReq: xhrReq,
    uploadFiles: uploadFiles,
    onFileChange: onFileChange,
    onNormalFileChange: onNormalFileChange,
    onDragFileChange: onDragFileChange,
    onRemove: onRemove,
    triggerUpload: triggerUpload,
    cancelUpload: cancelUpload
  };
}

export { useUpload as default };
//# sourceMappingURL=useUpload.js.map
