/**
 * tdesign v0.42.2
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var defineProperty = require('../../_chunks/dep-3415b40f.js');
var slicedToArray = require('../../_chunks/dep-8c98b84c.js');
var toConsumableArray = require('../../_chunks/dep-0944d665.js');
var React = require('react');
var get = require('../../_chunks/dep-f0b85a46.js');
var intersection = require('../../_chunks/dep-0100323b.js');
var hooks_useControlled = require('../../hooks/useControlled.js');
require('../../_chunks/dep-789d4bfb.js');
require('../../_chunks/dep-cc5ddaf7.js');
require('../../_chunks/dep-72f2b815.js');
require('../../_chunks/dep-6c4c2f3e.js');
require('../../_chunks/dep-f6abffca.js');
require('../../_chunks/dep-1ad27019.js');
require('../../_chunks/dep-3c510ebe.js');
require('../../_chunks/dep-be113066.js');
require('../../_chunks/dep-7affd9c7.js');
require('../../_chunks/dep-c15e2539.js');
require('../../_chunks/dep-b282bced.js');
require('../../_chunks/dep-b8187df5.js');
require('../../_chunks/dep-93234904.js');
require('../../_chunks/dep-482517f0.js');
require('../../_chunks/dep-ffd983b8.js');
require('../../_chunks/dep-901b688e.js');
require('../../_chunks/dep-6f0ad8f9.js');
require('../../_chunks/dep-bdb568fa.js');
require('../../_chunks/dep-92d05577.js');
require('../../_chunks/dep-29ecaf93.js');
require('../../_chunks/dep-f31114fd.js');
require('../../_chunks/dep-eb2281b7.js');
require('../../_chunks/dep-6d1aecc8.js');
require('../../_util/noop.js');

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { defineProperty._defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var childrenMap = /* @__PURE__ */new Map();
function getChildrenData(treeDataMap, data, keys, r) {
  if (childrenMap.get(data)) return childrenMap.get(data);
  var result = r || {
    allChildren: [],
    allChildrenKeys: [],
    leafNodeKeys: []
  };
  var children = get.get_1(data, keys.childrenKey);
  if (!children || !children.length) return result;
  var selectableChildren = children.filter(function (item) {
    var _treeDataMap$get;

    return !((_treeDataMap$get = treeDataMap.get(get.get_1(item, keys.rowKey))) !== null && _treeDataMap$get !== void 0 && _treeDataMap$get.disabled);
  });
  result.allChildren = toConsumableArray._toConsumableArray(new Set(result.allChildren.concat(selectableChildren)));

  for (var i = 0, len = children.length; i < len; i++) {
    var tItem = children[i];
    var c = get.get_1(tItem, keys.childrenKey);

    if (c !== null && c !== void 0 && c.length) {
      var nextLevelData = getChildrenData(treeDataMap, tItem, keys, result);
      result.allChildren = toConsumableArray._toConsumableArray(new Set(result.allChildren.concat(nextLevelData.allChildren)));
    }
  }

  for (var _i = 0, _len = result.allChildren.length; _i < _len; _i++) {
    var item = result.allChildren[_i];
    var children2 = get.get_1(item, keys.childrenKey);
    var rowValue = get.get_1(item, keys.rowKey);
    result.allChildrenKeys.push(rowValue);

    if (!children2 || !children2.length) {
      result.leafNodeKeys.push(rowValue);
    }
  }

  result.allChildrenKeys = toConsumableArray._toConsumableArray(new Set(result.allChildrenKeys));
  result.leafNodeKeys = toConsumableArray._toConsumableArray(new Set(result.leafNodeKeys));
  return result;
}
function removeChildrenKeys(p, r) {
  var selectedRowKeys = p.selectedRowKeys,
      removeKeys = p.removeKeys;
  var result = r || {
    data: [],
    keys: []
  };

  for (var i = 0, len = selectedRowKeys.length; i < len; i++) {
    var key = selectedRowKeys[i];

    if (!removeKeys.includes(key)) {
      result.keys.push(key);
    }
  }

  return result;
}
function getRowDataByKeys(p) {
  var treeDataMap = p.treeDataMap,
      selectedRowKeys = p.selectedRowKeys;
  var result = [];

  for (var i = 0, len = selectedRowKeys.length; i < len; i++) {
    var key = selectedRowKeys[i];
    result.push(treeDataMap.get(key));
  }

  return result;
}
function useTreeSelect(props, treeDataMap) {
  var tree = props.tree,
      rowKey = props.rowKey,
      data = props.data,
      indeterminateSelectedRowKeys = props.indeterminateSelectedRowKeys;

  var _useState = React.useState([]),
      _useState2 = slicedToArray._slicedToArray(_useState, 2),
      tIndeterminateSelectedRowKeys = _useState2[0],
      setTIndeterminateSelectedRowKeys = _useState2[1];

  var _useControlled = hooks_useControlled["default"](props, "selectedRowKeys", props.onSelectChange, {
    defaultSelectedRowKeys: props.defaultSelectedRowKeys || []
  }),
      _useControlled2 = slicedToArray._slicedToArray(_useControlled, 2),
      tSelectedRowKeys = _useControlled2[0],
      setTSelectedRowKeys = _useControlled2[1];

  var rowDataKeys = React.useMemo(function () {
    return {
      rowKey: rowKey || "id",
      childrenKey: (tree === null || tree === void 0 ? void 0 : tree.childrenKey) || "children"
    };
  }, [rowKey, tree === null || tree === void 0 ? void 0 : tree.childrenKey]);
  React.useEffect(function () {
    if (!tree || !treeDataMap.size || tree.checkStrictly) return;
    updateIndeterminateState();
  }, [tSelectedRowKeys, data, tree, treeDataMap]);

  function updateIndeterminateState() {
    if (!tree || tree.checkStrictly) return;

    if (!tSelectedRowKeys.length) {
      setTIndeterminateSelectedRowKeys([]);
      return;
    }

    var keys = [];
    var parentMap = {};

    for (var i = 0, len = tSelectedRowKeys.length; i < len; i++) {
      var rowValue = tSelectedRowKeys[i];
      var state = treeDataMap.get(rowValue);
      var children = get.get_1(state.row, rowDataKeys.childrenKey);

      if (!children || !children.length) {
        var parentTmp = state.parent;

        while (parentTmp) {
          if (!parentMap[parentTmp.id]) {
            parentMap[parentTmp.id] = [];
          }

          parentMap[parentTmp.id].push(state.row);
          var checkedLength = parentMap[parentTmp.id].length;

          var _getChildrenData = getChildrenData(treeDataMap, parentTmp.row, rowDataKeys),
              allChildrenKeys = _getChildrenData.allChildrenKeys;

          var parentTmpIndex = keys.indexOf(parentTmp.id);
          var selectedIndex = tSelectedRowKeys.indexOf(parentTmp.id);

          if (checkedLength > 0 && checkedLength < allChildrenKeys.length && selectedIndex === -1) {
            parentTmpIndex === -1 && keys.push(parentTmp.id);
          } else {
            parentTmpIndex !== -1 && keys.splice(parentTmpIndex, 1);
          }

          parentTmp = parentTmp.parent;
        }
      }
    }

    setTIndeterminateSelectedRowKeys(keys);
  }

  function updateParentCheckedState(selectedKeys, currentRowKey, type) {
    if (!tree || tree.checkStrictly) return;

    var keys = toConsumableArray._toConsumableArray(selectedKeys);

    var state = treeDataMap.get(currentRowKey);
    var parentTmp = state.parent;

    while (parentTmp) {
      var _getChildrenData2 = getChildrenData(treeDataMap, parentTmp.row, rowDataKeys),
          leafNodeKeys = _getChildrenData2.leafNodeKeys;

      var checkedChildrenKeys = intersection.intersection_1(leafNodeKeys, selectedKeys);
      var selectedIndex = keys.indexOf(parentTmp.id);

      if (type === "uncheck") {
        selectedIndex !== -1 && keys.splice(selectedIndex, 1);
      } else if (checkedChildrenKeys.length === leafNodeKeys.length) {
        selectedIndex === -1 && keys.push(parentTmp.id);
      }

      parentTmp = parentTmp.parent;
    }

    return keys;
  }

  function onInnerSelectChange(rowKeys, extraData) {
    if (!tree || tree.checkStrictly) {
      setTSelectedRowKeys(rowKeys, extraData);
      return;
    }

    if (extraData.currentRowKey === "CHECK_ALL_BOX") {
      handleSelectAll(extraData);
    } else {
      handleSelect(rowKeys, extraData);
    }
  }

  function handleSelectAll(extraData) {
    var newRowKeys = [];
    var newRowData = [];

    if ((extraData === null || extraData === void 0 ? void 0 : extraData.type) === "check") {
      var arr = toConsumableArray._toConsumableArray(treeDataMap.values());

      for (var i = 0, len = arr.length; i < len; i++) {
        var item = arr[i];

        if (!(item !== null && item !== void 0 && item.disabled)) {
          newRowData.push(item.row);
          newRowKeys.push(get.get_1(item.row, rowDataKeys.rowKey));
        }
      }
    }

    var newExtraData = _objectSpread(_objectSpread({}, extraData), {}, {
      selectedRowData: newRowData || []
    });

    setTSelectedRowKeys(newRowKeys, newExtraData);
  }

  function handleSelect(rowKeys, extraData) {
    var newRowKeys = toConsumableArray._toConsumableArray(rowKeys);

    if (tree.checkStrictly === false) {
      if (extraData.type === "check") {
        var result = getChildrenData(treeDataMap, extraData.currentRowData, rowDataKeys);
        var allChildrenKeys = result.allChildrenKeys;
        childrenMap.set(extraData.currentRowData, result);
        newRowKeys = toConsumableArray._toConsumableArray(new Set(newRowKeys.concat(allChildrenKeys)));
      } else if (extraData.type === "uncheck") {
        var children = getChildrenData(treeDataMap, extraData.currentRowData, rowDataKeys);

        var _result = removeChildrenKeys({
          selectedRowKeys: rowKeys,
          removeKeys: children.allChildrenKeys
        });

        newRowKeys = _result.keys;
      }
    }

    newRowKeys = updateParentCheckedState(newRowKeys, extraData.currentRowKey, extraData.type);
    var newRowData = getRowDataByKeys({
      treeDataMap: treeDataMap,
      selectedRowKeys: newRowKeys
    });

    var newExtraData = _objectSpread(_objectSpread({}, extraData), {}, {
      selectedRowData: newRowData
    });

    setTSelectedRowKeys(newRowKeys, newExtraData);
  }

  return {
    tIndeterminateSelectedRowKeys: indeterminateSelectedRowKeys || tIndeterminateSelectedRowKeys,
    onInnerSelectChange: onInnerSelectChange
  };
}

exports.childrenMap = childrenMap;
exports["default"] = useTreeSelect;
exports.getChildrenData = getChildrenData;
exports.getRowDataByKeys = getRowDataByKeys;
exports.removeChildrenKeys = removeChildrenKeys;
//# sourceMappingURL=useTreeSelect.js.map
